---
- name: Initial setup.
  hosts: all
  become: true
  tasks:
      - name: Ping hosts
        ansible.builtin.ping:

      - name: Update and upgrade apt packages
        ansible.builtin.apt:
            update_cache: true
            upgrade: true

- name: Install Docker.
  gather_facts: false
  hosts: all
  become: true
  tasks:
      - name: Install aptitude
        ansible.builtin.apt:
            name: aptitude
            state: present
            update_cache: true

      - name: Install required system packages
        ansible.builtin.apt:
            pkg:
                - apt-transport-https
                - ca-certificates
                - curl
            state: present
            update_cache: true

      - name: Add Docker GPG apt Key
        ansible.builtin.apt_key:
            url: https://download.docker.com/linux/ubuntu/gpg
            state: present

      - name: Add Docker Repository
        ansible.builtin.apt_repository:
            repo: deb https://download.docker.com/linux/ubuntu focal stable
            state: present

      - name: Install Docker
        ansible.builtin.apt:
            pkg:
                - docker-ce
                - docker-ce-cli
                - containerd.io
                - docker-buildx-plugin
                - docker-compose-plugin
            state: present
            update_cache: true

      - name: Test docker installation
        ansible.builtin.command:
            cmd: docker --version
        register: docker_version
        changed_when: docker_version.rc != 0

- name: Install cri-dockerd and Kubernetes Binaries Manually
  hosts: all
  become: true
  gather_facts: true

  vars:
      cni_plugins_version: "v1.3.0"
      crictl_version: "v1.31.0"
      k8s_release_utils_version: "v0.16.2"

      arch: "amd64"
      cri_dockerd_arch: "amd64"
      cni_dest_dir: "/opt/cni/bin"
      download_dir: "/usr/local/bin"
      cri_dockerd_bin_path: "{{ download_dir }}/cri-dockerd"
      systemd_dir: "/etc/systemd/system"

      # cri-dockerd Prefixes
      cri_dockerd_api_url: "https://api.github.com/repos/Mirantis/cri-dockerd/releases/latest"
      cri_dockerd_release_prefix: "https://github.com/Mirantis/cri-dockerd/releases/download"
      cri_dockerd_raw_prefix: "https://raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd"

      # CNI Plugins Prefix
      cni_plugins_release_prefix: "https://github.com/containernetworking/plugins/releases/download"

      # cri-tools (crictl) Prefix
      crictl_release_prefix: "https://github.com/kubernetes-sigs/cri-tools/releases/download"

      # K8s Release Utils (Templates) Prefix
      k8s_release_raw_prefix: "https://raw.githubusercontent.com/kubernetes/release"

      # --- Filenames and Paths (still useful) ---
      cni_plugins_archive_filename: "cni-plugins-linux-{{ arch }}-{{ cni_plugins_version }}.tgz"
      crictl_archive_filename: "crictl-{{ crictl_version }}-linux-{{ arch }}.tar.gz"
      kubelet_service_template_path: "{{ k8s_release_utils_version }}/cmd/krel/templates/latest/kubelet/kubelet.service"
      kubeadm_conf_template_path: "{{ k8s_release_utils_version }}/cmd/krel/templates/latest/kubeadm/10-kubeadm.conf"

      # --- Systemd unit file paths for kubelet ---
      kubelet_service_file: "{{ systemd_dir }}/kubelet.service"
      kubelet_conf_dir: "{{ systemd_dir }}/kubelet.service.d"
      kubelet_conf_file: "{{ kubelet_conf_dir }}/10-kubeadm.conf"

  tasks:
      # Install cri-dockerd
      - name: Check if cri-dockerd is already installed
        ansible.builtin.stat:
            path: "{{ cri_dockerd_bin_path }}"
        register: cri_dockerd_binary_stat

      - name: Block for cri-dockerd installation tasks
        when: not cri_dockerd_binary_stat.stat.exists
        block:
            - name: Install prerequisites (curl/wget, tar)
              ansible.builtin.package:
                  name:
                      - curl
                      - tar
                      - ca-certificates
                  state: present

            - name: Get latest cri-dockerd release tag from GitHub API
              ansible.builtin.uri:
                  url: "{{ cri_dockerd_api_url }}"
                  return_content: true
                  headers:
                      Accept: application/vnd.github.v3+json
              register: cri_dockerd_latest_release
              check_mode: false

            - name: Exit if GitHub API call failed
              ansible.builtin.fail:
                  msg: "Failed to retrieve cri-dockerd latest release info from {{ cri_dockerd_api_url }}. Status: {{ cri_dockerd_latest_release.status }}"
              when: cri_dockerd_latest_release.status != 200

            - name: Extract cri-dockerd version from tag
              ansible.builtin.set_fact:
                  cri_dockerd_version: "{{ (cri_dockerd_latest_release.content | from_json).tag_name | regex_replace('^v', '') }}"

            - name: Define cri-dockerd download URL and paths
              ansible.builtin.set_fact:
                  cri_dockerd_tmp_archive: "/tmp/cri-dockerd-{{ cri_dockerd_version }}.{{ cri_dockerd_arch }}.tgz"
                  cri_dockerd_tmp_extract_dir: "/tmp/cri-dockerd-extract-{{ cri_dockerd_version }}"

            - name: Download cri-dockerd archive
              ansible.builtin.get_url:
                  url: "{{ cri_dockerd_release_prefix }}/v{{ cri_dockerd_version }}/cri-dockerd-{{ cri_dockerd_version }}.{{ cri_dockerd_arch }}.tgz"
                  dest: "{{ cri_dockerd_tmp_archive }}"
                  mode: "0644"

            - name: Ensure temporary extraction directory exists and is empty
              ansible.builtin.file:
                  path: "{{ cri_dockerd_tmp_extract_dir }}"
                  state: absent
              check_mode: false

            - name: Ensure temporary extraction directory exists
              ansible.builtin.file:
                  path: "{{ cri_dockerd_tmp_extract_dir }}"
                  state: directory
                  mode: "0755"

            - name: Extract cri-dockerd archive
              ansible.builtin.unarchive:
                  src: "{{ cri_dockerd_tmp_archive }}"
                  dest: "{{ cri_dockerd_tmp_extract_dir }}"
                  remote_src: true

            - name: Ensure destination directory for binary exists
              ansible.builtin.file:
                  path: "{{ cri_dockerd_bin_path | dirname }}"
                  state: directory
                  mode: "0755"

            - name: Move cri-dockerd binary to final destination
              ansible.builtin.copy:
                  src: "{{ cri_dockerd_tmp_extract_dir }}/cri-dockerd/cri-dockerd"
                  dest: "{{ cri_dockerd_bin_path }}"
                  remote_src: true
                  mode: "0755"
                  owner: root
                  group: root
              notify: Clean up cri-dockerd temp files

            - name: Download cri-docker.service systemd file
              ansible.builtin.get_url:
                  url: "{{ cri_dockerd_raw_prefix }}/cri-docker.service"
                  dest: "{{ systemd_dir }}/cri-docker.service"
                  mode: "0644"
              register: cri_service_download

            - name: Download cri-docker.socket systemd file
              ansible.builtin.get_url:
                  url: "{{ cri_dockerd_raw_prefix }}/cri-docker.socket"
                  dest: "{{ systemd_dir }}/cri-docker.socket"
                  mode: "0644"
              register: cri_socket_download

            - name: Modify cri-docker.service to point to correct binary path
              ansible.builtin.replace:
                  path: "{{ systemd_dir }}/cri-docker.service"
                  regexp: "/usr/bin/cri-dockerd"
                  replace: "{{ cri_dockerd_bin_path }}"
              when: cri_service_download.changed or cri_socket_download.changed
              notify: Reload systemd and restart cri-dockerd

            # --- Systemd Handling for cri-dockerd ---
            - name: Force systemd daemon-reload (cri-dockerd)
              ansible.builtin.systemd:
                  daemon_reload: true
              when: cri_service_download.changed or cri_socket_download.changed

            - name: Enable cri-docker service
              ansible.builtin.systemd:
                  name: cri-docker.service
                  enabled: true

            - name: Enable and start cri-docker socket
              ansible.builtin.systemd:
                  name: cri-docker.socket
                  enabled: true
                  state: started

      # Install CNI / crictl / kubeadm / kubelet
      - name: Ensure CNI destination directory exists
        ansible.builtin.file:
            path: "{{ cni_dest_dir }}"
            state: directory
            mode: "0755"

      - name: Download and extract CNI plugins
        ansible.builtin.unarchive:
            src: "{{ cni_plugins_release_prefix }}/{{ cni_plugins_version }}/{{ cni_plugins_archive_filename }}"
            dest: "{{ cni_dest_dir }}"
            remote_src: true
            creates: "{{ cni_dest_dir }}/bridge"

      - name: Ensure binary download directory exists
        ansible.builtin.file:
            path: "{{ download_dir }}"
            state: directory
            mode: "0755"

      - name: Download and extract crictl
        ansible.builtin.unarchive:
            src: "{{ crictl_release_prefix }}/{{ crictl_version }}/{{ crictl_archive_filename }}"
            dest: "{{ download_dir }}"
            remote_src: true
            mode: "0755"
            creates: "{{ download_dir }}/crictl"

      - name: Get latest stable Kubernetes release version string
        ansible.builtin.uri:
            url: https://dl.k8s.io/release/stable.txt
            return_content: true
        register: k8s_stable_release
        check_mode: false

      - name: Set stable release fact
        ansible.builtin.set_fact:
            k8s_release: "{{ k8s_stable_release.content | trim }}"

      - name: Download kubeadm binary
        ansible.builtin.get_url:
            url: "https://dl.k8s.io/release/{{ k8s_release }}/bin/linux/{{ arch }}/kubeadm"
            dest: "{{ download_dir }}/kubeadm"
            mode: "0755"
            force: false

      - name: Download kubelet binary
        ansible.builtin.get_url:
            url: "https://dl.k8s.io/release/{{ k8s_release }}/bin/linux/{{ arch }}/kubelet"
            dest: "{{ download_dir }}/kubelet"
            mode: "0755"
            force: false

      # --- Kubelet Systemd Setup ---
      - name: Fetch kubelet systemd service template content
        ansible.builtin.uri:
            url: "{{ k8s_release_raw_prefix }}/{{ kubelet_service_template_path }}"
            return_content: true
        register: kubelet_service_template
        check_mode: false

      - name: Create kubelet systemd service file from template
        ansible.builtin.copy:
            content: "{{ kubelet_service_template.content | replace('/usr/bin', download_dir) }}"
            dest: "{{ kubelet_service_file }}"
            mode: "0644"
        notify: Reload systemd and restart kubelet

      - name: Ensure kubelet systemd drop-in directory exists
        ansible.builtin.file:
            path: "{{ kubelet_conf_dir }}"
            state: directory
            mode: "0755"

      - name: Fetch kubeadm systemd drop-in template content
        ansible.builtin.uri:
            url: "{{ k8s_release_raw_prefix }}/{{ kubeadm_conf_template_path }}"
            return_content: true
        register: kubeadm_conf_template
        check_mode: false

      - name: Create kubeadm systemd drop-in file from template
        ansible.builtin.copy:
            content: "{{ kubeadm_conf_template.content | replace('/usr/bin', download_dir) }}"
            dest: "{{ kubelet_conf_file }}"
            mode: "0644"
        notify: Reload systemd and restart kubelet

      - name: Ensure kubelet service is enabled
        ansible.builtin.systemd:
            name: kubelet
            enabled: true

      - name: Disable Swap
        ansible.builtin.command:
            cmd: swapoff -a
        register: swapoff_result
        changed_when: swapoff_result.rc != 0

      - name: Disable swap - comment out swap entries in fstab using replace
        ansible.builtin.replace:
            # sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
            path: /etc/fstab
            regexp: '^(?!\s*#)(.*\sswap\s.*)$'
            replace: '# \1'
            backup: true
        when: swapoff_result.rc == 0

  handlers:
      - name: Reload systemd and restart kubelet
        ansible.builtin.systemd:
            name: kubelet
            daemon_reload: true
            state: restarted

      - name: Reload systemd and restart cri-dockerd
        ansible.builtin.systemd:
            name: cri-docker.service
            daemon_reload: true
            state: restarted
        listen: Reload systemd and restart cri-dockerd

      - name: Clean up cri-dockerd temp files
        ansible.builtin.file:
            path: "{{ item }}"
            state: absent
        loop:
            - "{{ cri_dockerd_tmp_archive }}"
            - "{{ cri_dockerd_tmp_extract_dir }}"
        check_mode: false

- name: Start kubeadm on master
  hosts: master
  become: true
  gather_facts: false
  vars:
      setup_user: "{{ ansible_user_id }}"
      setup_group: "{{ ansible_user_gid }}"
      setup_home: "{{ ansible_env.HOME }}"
      setup_home_fallback: "/home/{{ setup_user }}"
  tasks:
      - name: Reset kubeadm.
        ansible.builtin.command:
            cmd: kubeadm reset --cri-socket=unix:///var/run/cri-dockerd.sock -f
        register: reset_result
        changed_when: reset_result.rc != 0

      - name: Initialize kubernetes cluster.
        ansible.builtin.command:
            cmd: kubeadm init --cri-socket=unix:///var/run/cri-dockerd.sock --pod-network-cidr=10.244.0.0/16
        register: init_result
        changed_when: init_result.rc != 0
        failed_when: init_result.rc != 0 and 'kubeadm has already been initialized' not in init_result.stderr

      - name: Determine effective home directory path
        ansible.builtin.set_fact:
            effective_home: "{{ setup_home | default(setup_home_fallback) }}"

      - name: Fail if effective home directory could not be determined
        ansible.builtin.fail:
            msg: >-
                Could not determine home directory for user '{{ setup_user }}'.
                Tried ansible_env.HOME and fallback '{{ setup_home_fallback }}'.
                Check gathered facts or set 'setup_home' variable explicitly.
        when: effective_home is not defined or effective_home == ""

      - name: Create .kube directory in user's home
        ansible.builtin.file:
            path: "{{ effective_home }}/.kube"
            state: directory
            owner: "{{ setup_user }}"
            group: "{{ setup_group }}"
            mode: "0700"

      - name: Copy admin.conf to user's .kube/config and set ownership
        ansible.builtin.copy:
            src: /etc/kubernetes/admin.conf
            dest: "{{ effective_home }}/.kube/config"
            remote_src: true
            owner: "{{ setup_user }}"
            group: "{{ setup_group }}"
            mode: "0600"
            backup: true

- name: Join Worker Nodes to Cluster
  hosts: workers
  become: true
  gather_facts: false

  vars:
      control_plane_node: "{{ groups['master'][0] }}"
      cri_socket_path: "unix:///var/run/cri-dockerd.sock"

  tasks:
      - name: Retrieve join command from control plane node
        ansible.builtin.command:
            cmd: kubeadm token create --print-join-command
        register: join_command_result
        delegate_to: "{{ control_plane_node }}" # Run this command on the master
        changed_when: false
        failed_when: join_command_result.rc != 0

      - name: Extract the join command string
        ansible.builtin.set_fact:
            kubeadm_join_command: "{{ join_command_result.stdout | trim }}"

      - name: Join worker node to the cluster
        ansible.builtin.command:
            cmd: "{{ kubeadm_join_command }} --cri-socket={{ cri_socket_path }}"
            creates: /etc/kubernetes/kubelet.conf
        register: join_worker_result
        changed_when: join_worker_result.rc == 0

- name: Install and Configure CockroachDB Cluster
  hosts: cockroachdb
  become: true
  vars:
      crdb_version: "v25.1.0"
      crdb_binary_url: "https://binaries.cockroachdb.com/cockroach-{{ crdb_version }}.linux-amd64.tgz"
      crdb_install_dir: "/usr/local/bin"
      crdb_data_dir: "/var/lib/cockroach"
      crdb_run_dir: "/var/run/cockroach"
      crdb_download_dest: "/tmp/cockroach-{{ crdb_version }}.linux-amd64.tgz"
      crdb_extract_dest: "/tmp"
      crdb_extracted_path: "/tmp/cockroach-{{ crdb_version }}.linux-amd64/cockroach"
      crdb_user: cockroach
      crdb_group: cockroach

  tasks:
      - name: Ensure cockroach group exists
        ansible.builtin.group:
            name: "{{ crdb_group }}"
            state: present
            system: true

      - name: Ensure cockroach user exists
        ansible.builtin.user:
            name: "{{ crdb_user }}"
            group: "{{ crdb_group }}"
            home: "{{ crdb_data_dir }}"
            shell: /sbin/nologin
            system: true
            create_home: false
            state: present

      - name: Install chrony NTP client
        ansible.builtin.package:
            name: chrony
            state: present
        register: chrony_install_result

      - name: Configure chrony to use Google NTP servers
        ansible.builtin.blockinfile:
            path: /etc/chrony/chrony.conf
            block: |
                # Google Public NTP Servers
                server time1.google.com iburst prefer
                server time2.google.com iburst
                server time3.google.com iburst
                server time4.google.com iburst
            marker: "# {mark} ANSIBLE MANAGED BLOCK - Google NTP"
            state: present
        notify: Restart chrony
        when: chrony_install_result is success

      - name: Ensure chrony service is running and enabled
        ansible.builtin.service:
            name: chrony
            state: started
            enabled: true
        when: chrony_install_result is success

      - name: Ensure target directories exist
        ansible.builtin.file:
            path: "{{ item }}"
            state: directory
            owner: "{{ crdb_user }}"
            group: "{{ crdb_group }}"
            mode: "0700"
        loop:
            - "{{ crdb_data_dir }}"

      - name: Check if CockroachDB binary already exists
        ansible.builtin.stat:
            path: "{{ crdb_install_dir }}/cockroach"
        register: cockroach_binary_stat

      - name: Ensure runtime directory exists
        ansible.builtin.file:
            path: "{{ crdb_run_dir }}"
            state: directory
            owner: "{{ crdb_user }}"
            group: "{{ crdb_group }}"
            mode: "0755"

      - name: Download CockroachDB binary archive
        ansible.builtin.get_url:
            url: "{{ crdb_binary_url }}"
            dest: "{{ crdb_download_dest }}"
            mode: "0644"
        when: not cockroach_binary_stat.stat.exists

      - name: Extract CockroachDB archive
        ansible.builtin.unarchive:
            src: "{{ crdb_download_dest }}"
            dest: "{{ crdb_extract_dest }}"
            remote_src: true
            creates: "{{ crdb_extracted_path }}"

        when:
            - not ansible_check_mode
            - not cockroach_binary_stat.stat.exists

      - name: Stat extracted binary path
        ansible.builtin.stat:
            path: "{{ crdb_extracted_path }}"
        register: crdb_extracted_stat
        when: not cockroach_binary_stat.stat.exists

      - name: Copy CockroachDB binary to install directory
        ansible.builtin.copy:
            src: "{{ crdb_extracted_path }}"
            dest: "{{ crdb_install_dir }}/cockroach"
            remote_src: true
            owner: root
            group: root
            mode: "0755"
        when:
            - not cockroach_binary_stat.stat.exists
            - crdb_extracted_stat.stat is defined and crdb_extracted_stat.stat.exists
        notify:
            - Reload systemd

      - name: Clean up downloaded archive and extracted files
        ansible.builtin.file:
            path: "{{ item }}"
            state: absent
        loop:
            - "{{ crdb_download_dest }}"
            - "/tmp/cockroach-{{ crdb_version }}.linux-amd64"
        when: not ansible_check_mode

      - name: Template CockroachDB systemd service file
        ansible.builtin.template:
            src: templates/cockroachdb.service.j2
            dest: /etc/systemd/system/cockroachdb.service
            owner: root
            group: root
            mode: "0644"
        notify:
            - Reload systemd
            - Restart cockroachdb

      - name: Ensure CockroachDB service is enabled and started
        ansible.builtin.systemd:
            name: cockroachdb
            enabled: true
            state: started
            daemon_reload: true

  handlers:
      - name: Reload systemd
        ansible.builtin.systemd:
            daemon_reload: true

      - name: Restart cockroachdb
        ansible.builtin.systemd:
            name: cockroachdb
            state: restarted

      - name: Restart chrony
        ansible.builtin.service:
            name: chrony
            state: restarted
            enabled: true

- name: Initialize the CockroachDB Cluster
  hosts: cockroachdb[0]
  become: true
  gather_facts: false

  tasks:
      - name: Initialize the cluster (runs only once)
        ansible.builtin.command:
            cmd: "{{ crdb_install_dir }}/cockroach init --insecure --host={{ ansible_host }}:26257 -v"
        register: init_result
        changed_when: init_result.rc == 0
        failed_when: init_result.rc != 0 and 'cluster has already been initialized' not in init_result.stderr
        vars:
            crdb_install_dir: "/usr/local/bin"
        delay: 10
        retries: 3
        until: init_result is success or 'cluster has already been initialized' in init_result.stderr

      - name: Display initialization result
        ansible.builtin.debug:
            var: init_result
            verbosity: 1

- name: Apply CockroachDB Enterprise License (Plain Text File - Insecure)
  hosts: cockroachdb[0]
  become: false
  gather_facts: false
  vars_files:
      - vars/crdb_secrets.yml

  vars:
      crdb_install_dir: "/usr/local/bin"

  tasks:
      - name: Set CockroachDB enterprise license key
        ansible.builtin.command:
            cmd: >-
                {{ crdb_install_dir }}/cockroach sql
                --execute="SET CLUSTER SETTING enterprise.license = '{{ crdb_enterprise_license_key }}';"
                --host={{ ansible_host }}:26257 --insecure
        register: set_license_result
        changed_when: "'cluster setting updated' in set_license_result.stdout"

- name: Install and Configure MinIO (Single Node Single Drive)
  hosts: minio
  become: true
  vars_files:
      - vars/minio_secrets.yml
  vars:
      # --- MinIO Configuration ---
      minio_user: "minio-user"
      minio_group: "minio-user"
      minio_home_dir: "/var/local/minio"
      minio_install_dir: "/usr/local/bin"
      minio_config_dir: "/etc/minio"
      minio_env_file_path: "/etc/default/minio"
      minio_binary_url: "https://dl.min.io/server/minio/release/linux-amd64/minio"
      minio_limit_nofile: 1048576
      minio_console_port: 9001
      # --- Define ONE data directory ---
      # IMPORTANT: Separate storage (mounted here) is still recommended for performance/reliability.
      # If this path is on the root drive, MinIO *might* still fail without MINIO_CI_CD=true workaround.
      minio_data_dir: "/mnt/minio-data"

  tasks:
      - name: Ensure MinIO group exists
        ansible.builtin.group:
            name: "{{ minio_group }}"
            state: present
            system: true

      - name: Ensure MinIO user exists
        ansible.builtin.user:
            name: "{{ minio_user }}"
            group: "{{ minio_group }}"
            home: "{{ minio_home_dir }}"
            shell: /sbin/nologin
            system: true
            create_home: true
            state: present

      - name: Ensure MinIO data directory exists (including parents) and has correct permissions
        ansible.builtin.file:
            path: "{{ minio_data_dir }}"
            state: directory
            owner: "{{ minio_user }}"
            group: "{{ minio_group }}"
            mode: "0750"

      - name: Ensure MinIO config directory exists
        ansible.builtin.file:
            path: "{{ minio_config_dir }}"
            state: directory
            owner: root
            group: "{{ minio_group }}"
            mode: "0750"

      - name: Check if MinIO binary already exists
        ansible.builtin.stat:
            path: "{{ minio_install_dir }}/minio"
        register: minio_binary_stat

      - name: Download MinIO server binary
        ansible.builtin.get_url:
            url: "{{ minio_binary_url }}"
            dest: "{{ minio_install_dir }}/minio"
            mode: "0755"
            owner: root
            group: root
        when: not minio_binary_stat.stat.exists

      - name: Template MinIO environment file (credentials)
        ansible.builtin.template:
            src: templates/minio.default.j2
            dest: "{{ minio_env_file_path }}"
            owner: root
            group: "{{ minio_group }}"
            mode: "0640"
        notify: Restart minio

      - name: Template MinIO systemd service file (SNSD version)
        ansible.builtin.template:
            src: templates/minio.service.j2
            dest: /etc/systemd/system/minio.service
            owner: root
            group: root
            mode: "0644"
        notify: Reload systemd

      - name: Ensure MinIO service is enabled and started
        ansible.builtin.systemd:
            name: minio
            enabled: true
            state: started
            daemon_reload: true

  handlers:
      - name: Reload systemd
        ansible.builtin.systemd:
            daemon_reload: true

      - name: Restart minio
        ansible.builtin.systemd:
            name: minio
            state: restarted
            enabled: true

- name: Install RabbitMQ using Shell Script and Restart via Handler
  hosts: rabbitmq
  become: true
  vars:
      install_script_local_path: "scripts/install-rabbitmq.sh"

  tasks:
      - name: Run the RabbitMQ installation script
        ansible.builtin.script: "{{ install_script_local_path }}"
        args:
            creates: /etc/apt/sources.list.d/rabbitmq.list
        register: script_execution_result
        changed_when: >
            '0 upgraded, 0 newly installed' not in script_execution_result.stdout and
            'Setting up rabbitmq-server' in script_execution_result.stdout
        notify: Restart rabbitmq-server

  handlers:
      - name: Restart rabbitmq-server
        ansible.builtin.systemd:
            name: rabbitmq-server
            state: restarted
            enabled: true
        listen: "Restart rabbitmq-server"
